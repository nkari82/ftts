#include "PCH.h"

namespace ftts
{
	// https://apps.nolanlawson.com/japanese-name-converter/#?q=Ki
	static std::vector<std::pair<std::string, std::string>> e2k =
	{
		{"Ki", b3(0xE3,0x82,0xAD)},		// キ
		{"jung", b12(0xE3,0x82,0xB8,0xE3,0x83,0xA5,0xE3,0x83,0xB3,0xE3,0x82,0xB0)}, // ジュング
		{"Kim", b6(0xE3,0x82,0xAD,0xE3,0x83,0xA0)}, // キム
		{"taek", b9(0xE3,0x82,0xBF,0xE3,0x82,0xA8,0xE3,0x82,0xAF) }, // タエク
		{"woo", b6(0xE3,0x82,0xA6,0xE3,0x83,0xBC) }, // ウー
		{"wi", b6(0xE3,0x82,0xA6,0xE3,0x82,0xA3)}, // ウィ
		{"fi", b6(0xE3,0x83,0x95,0xE3,0x82,0xA3)},	// フィ
		{"coffee", b12(0xE3,0x82,0xB3,0xE3,0x83,0x95,0xE3,0x82,0xA3,0xE3,0x83,0xBC)},		// コフィー
		{"land", b10(0xE3,0x83,0xA9,0xE3,0x83,0xB3,0xE3,0x83,0x89,0x20)},	// ランド 
		{"Whats", b9(0xE3,0x82,0xA6,0xE3,0x82,0xA9,0xE3,0x83,0x84)}, // ウォツ
		{"App", b16(0xE3,0x82,0xA8,0xE3,0x83,0xBC,0xE3,0x83,0x83,0xE3,0x83,0x83,0xE3,0x83,0x97,0x20)}, // エーッップ 
		{"iptime", b18(0xE3,0x82,0xA4,0xE3,0x83,0x97,0xE3,0x83,0x86,0xE3,0x82,0xA3,0xE3,0x83,0x9F,0xE3,0x83,0xBC)}, // イプティミー
	};

	static std::vector <std::pair<std::string, std::string>> h2k =
	{
		{b3(0xE3,0x81,0x80), b3(0xE3,0x82,0xA0)},	// ぀
		{b3(0xE3,0x81,0x81), b3(0xE3,0x82,0xA1)}, 	// ぁ
		{b3(0xE3,0x81,0x82), b3(0xE3,0x82,0xA2)}, 	// あ
		{b3(0xE3,0x81,0x83), b3(0xE3,0x82,0xA3)}, 	// ぃ
		{b3(0xE3,0x81,0x84), b3(0xE3,0x82,0xA4)}, 	// い
		{b3(0xE3,0x81,0x85), b3(0xE3,0x82,0xA5)}, 	// ぅ
		{b3(0xE3,0x81,0x86), b3(0xE3,0x82,0xA6)}, 	// う
		{b3(0xE3,0x81,0x87), b3(0xE3,0x82,0xA7)}, 	// ぇ
		{b3(0xE3,0x81,0x88), b3(0xE3,0x82,0xA8)}, 	// え
		{b3(0xE3,0x81,0x89), b3(0xE3,0x82,0xA9)}, 	// ぉ
		{b3(0xE3,0x81,0x8a), b3(0xE3,0x82,0xAa)}, 	// お
		{b3(0xE3,0x81,0x8b), b3(0xE3,0x82,0xAb)}, 	// か
		{b3(0xE3,0x81,0x8c), b3(0xE3,0x82,0xAc)}, 	// が
		{b3(0xE3,0x81,0x8d), b3(0xE3,0x82,0xAd)}, 	// き
		{b3(0xE3,0x81,0x8e), b3(0xE3,0x82,0xAe)}, 	// ぎ
		{b3(0xE3,0x81,0x8f), b3(0xE3,0x82,0xAf)}, 	// く
		{b3(0xE3,0x81,0x90), b3(0xE3,0x82,0xB0)},
		{b3(0xE3,0x81,0x91), b3(0xE3,0x82,0xB1)},
		{b3(0xE3,0x81,0x92), b3(0xE3,0x82,0xB2)},
		{b3(0xE3,0x81,0x93), b3(0xE3,0x82,0xB3)},
		{b3(0xE3,0x81,0x94), b3(0xE3,0x82,0xB4)},
		{b3(0xE3,0x81,0x95), b3(0xE3,0x82,0xB5)},
		{b3(0xE3,0x81,0x96), b3(0xE3,0x82,0xB6)},
		{b3(0xE3,0x81,0x97), b3(0xE3,0x82,0xB7)},
		{b3(0xE3,0x81,0x98), b3(0xE3,0x82,0xB8)},
		{b3(0xE3,0x81,0x99), b3(0xE3,0x82,0xB9)},
		{b3(0xE3,0x81,0x9a), b3(0xE3,0x82,0xBa)},
		{b3(0xE3,0x81,0x9b), b3(0xE3,0x82,0xBb)},	// せ
		{b3(0xE3,0x81,0x9c), b3(0xE3,0x82,0xB)},
		{b3(0xE3,0x81,0x9d), b3(0xE3,0x82,0xBd)},
		{b3(0xE3,0x81,0x9e), b3(0xE3,0x82,0xBe)},
		{b3(0xE3,0x81,0x9f), b3(0xE3,0x82,0xBf)},		// た
		{b3(0xE3,0x81,0xA0), b3(0xE3,0x83,0x80)},
		{b3(0xE3,0x81,0xA1), b3(0xE3,0x83,0x81)},
		{b3(0xE3,0x81,0xA2), b3(0xE3,0x83,0x82)},
		{b3(0xE3,0x81,0xA3), b3(0xE3,0x83,0x83)},
		{b3(0xE3,0x81,0xA4), b3(0xE3,0x83,0x84)},
		{b3(0xE3,0x81,0xA5), b3(0xE3,0x83,0x85)},
		{b3(0xE3,0x81,0xA6), b3(0xE3,0x83,0x86)},
		{b3(0xE3,0x81,0xA7), b3(0xE3,0x83,0x87)},
		{b3(0xE3,0x81,0xA8), b3(0xE3,0x83,0x88)},
		{b3(0xE3,0x81,0xA9), b3(0xE3,0x83,0x89)},
		{b3(0xE3,0x81,0xAa), b3(0xE3,0x83,0x8a)},
		{b3(0xE3,0x81,0xAb), b3(0xE3,0x83,0x8b)},
		{b3(0xE3,0x81,0xAc), b3(0xE3,0x83,0x8c)},
		{b3(0xE3,0x81,0xAd), b3(0xE3,0x83,0x8d)},
		{b3(0xE3,0x81,0xAe), b3(0xE3,0x83,0x8e)},
		{b3(0xE3,0x81,0xAf), b3(0xE3,0x83,0x8f)}, 	// は
		{b3(0xE3,0x81,0xB0), b3(0xE3,0x83,0x90)},	// ば
		{b3(0xE3,0x81,0xB1), b3(0xE3,0x83,0x91)},
		{b3(0xE3,0x81,0xB2), b3(0xE3,0x83,0x92)},
		{b3(0xE3,0x81,0xB3), b3(0xE3,0x83,0x93)},
		{b3(0xE3,0x81,0xB4), b3(0xE3,0x83,0x94)},
		{b3(0xE3,0x81,0xB5), b3(0xE3,0x83,0x95)},
		{b3(0xE3,0x81,0xB6), b3(0xE3,0x83,0x96)},
		{b3(0xE3,0x81,0xB7), b3(0xE3,0x83,0x97)},
		{b3(0xE3,0x81,0xB8), b3(0xE3,0x83,0x98)},
		{b3(0xE3,0x81,0xB9), b3(0xE3,0x83,0x99)},
		{b3(0xE3,0x81,0xBa), b3(0xE3,0x83,0x9a)},
		{b3(0xE3,0x81,0xBb), b3(0xE3,0x83,0x9b)},
		{b3(0xE3,0x81,0xBc), b3(0xE3,0x83,0x9c)},
		{b3(0xE3,0x81,0xBd), b3(0xE3,0x83,0x9d)},
		{b3(0xE3,0x81,0xBe), b3(0xE3,0x83,0x9e)},
		{b3(0xE3,0x81,0xBf), b3(0xE3,0x83,0x9f)}, 		// み
		{b3(0xE3,0x82,0x80), b3(0xE3,0x83,0xA0)},
		{b3(0xE3,0x82,0x81), b3(0xE3,0x83,0xA1)},
		{b3(0xE3,0x82,0x82), b3(0xE3,0x83,0xA2)},
		{b3(0xE3,0x82,0x83), b3(0xE3,0x83,0xA3)},
		{b3(0xE3,0x82,0x84), b3(0xE3,0x83,0xA4)},
		{b3(0xE3,0x82,0x85), b3(0xE3,0x83,0xA5)},
		{b3(0xE3,0x82,0x86), b3(0xE3,0x83,0xA6)},
		{b3(0xE3,0x82,0x87), b3(0xE3,0x83,0xA7)},
		{b3(0xE3,0x82,0x88), b3(0xE3,0x83,0xA8)},
		{b3(0xE3,0x82,0x89), b3(0xE3,0x83,0xA9)},
		{b3(0xE3,0x82,0x8a), b3(0xE3,0x83,0xAa)},
		{b3(0xE3,0x82,0x8b), b3(0xE3,0x83,0xAb)},
		{b3(0xE3,0x82,0x8c), b3(0xE3,0x83,0xAc)},
		{b3(0xE3,0x82,0x8d), b3(0xE3,0x83,0xAd)},
		{b3(0xE3,0x82,0x8e), b3(0xE3,0x83,0xAe)},
		{b3(0xE3,0x82,0x8f), b3(0xE3,0x83,0xAf)}, 	// わ
		{b3(0xE3,0x82,0x90), b3(0xE3,0x83,0xB0)},
		{b3(0xE3,0x82,0x91), b3(0xE3,0x83,0xB1)},
		{b3(0xE3,0x82,0x92), b3(0xE3,0x83,0xB2)},
		{b3(0xE3,0x82,0x93), b3(0xE3,0x83,0xB3)},
		{b3(0xE3,0x82,0x94), b3(0xE3,0x83,0xB4)},
		{b3(0xE3,0x82,0x95), b3(0xE3,0x83,0xB5)},
		{b3(0xE3,0x82,0x96), b3(0xE3,0x83,0xB6)},
		{b3(0xE3,0x82,0x97), b3(0xE3,0x83,0xB7)},
		{b3(0xE3,0x82,0x98), b3(0xE3,0x83,0xB8)},
		{b3(0xE3,0x82,0x99), b3(0xE3,0x83,0xB9)},
		{b3(0xE3,0x82,0x9a), b3(0xE3,0x83,0xBa)},
		{b3(0xE3,0x82,0x9b), b3(0xE3,0x83,0xBb)},
		{b3(0xE3,0x82,0x9c), b3(0xE3,0x83,0xB)},
		{b3(0xE3,0x82,0x9d), b3(0xE3,0x83,0xBd)},
		{b3(0xE3,0x82,0x9e), b3(0xE3,0x83,0xBe)},
		{b3(0xE3,0x82,0x9f), b3(0xE3,0x83,0xBf)}		// ゟ
	};

	JSProcessor::JSProcessor(const std::vector<std::string>& args) : eos_(0xffffffff)
		, tagger_(MeCab::createTagger(args[0].c_str()))
		, empty_("")
		, punctuation_
	{
		b1(0x2d), // "-"
		b1(0x2c), // ","
		b3(0xe3,0x80,0x81), // "、"
		b3(0xe3,0x80,0x82), // "。"
		b3(0xef,0xbc,0x81), // "！"
		b3(0xef,0xbc,0x9f), // "？"
		b1(0x21), // "!"
		b1(0x3f) // "?"
	}
		, cleaner_
	{
		b1(0x20),  // " "
		b3(0xe3,0x80,0x80), // "　"
		b3(0xe3,0x80,0x8c), // "「"
		b3(0xe3,0x80,0x8d), // "」"
		b3(0xe3,0x80,0x8e), // "『"
		b3(0xe3,0x80,0x8f), // "』"
		b3(0xe3,0x83,0xbb), // "・"
		b3(0xe3,0x80,0x90), // "【"
		b3(0xe3,0x80,0x91), // "】"
		b3(0xef,0xbc,0x88), // "（"
		b3(0xef,0xbc,0x89), // "）"
		b1(0x28), // "("
		b1(0x29) // ")"
	}
		, normalize_
	{
		{b3(0xe3,0x80,0x9c), b3(0xe3,0x83,0xbc)}, // replace('〜', 'ー')
		{b3(0xef,0xbd,0x9e), b3(0xe3,0x83,0xbc)}, // replace('～', 'ー')
		{b3(0xe2,0x80,0x99), b1(0x27)}, // replace("’", "'")
		{b3(0xe2,0x80,0x9d), b1(0x22)}, // replace('”', '"')
		{b3(0xe2,0x80,0x9c), b2(0x60,0x60)}, // replace('“', '``')
		{b2(0xcb,0x97), b1(0x2d)}, // replace('˗', '-')
		{b2(0xd6,0x8a), b1(0x2d)}, // replace('֊', '-')
		{b3(0xe2,0x80,0x90), b1(0x2d)}, // replace('‐', '-')
		{b3(0xe2,0x80,0x91), b1(0x2d)}, // replace('‑', '-')
		{b3(0xe2,0x80,0x92), b1(0x2d)}, // replace('‒', '-')
		{b3(0xe2,0x80,0x93), b1(0x2d)}, // replace('–', '-')
		{b3(0xe2,0x81,0x83), b1(0x2d)}, // replace('⁃', '-')
		{b3(0xe2,0x81,0xbb), b1(0x2d)}, // replace('⁻', '-')
		{b3(0xe2,0x82,0x8b), b1(0x2d)}, // replace('₋', '-')
		{b3(0xe2,0x88,0x92), b1(0x2d)}, // replace('−', '-')
		{b3(0xef,0xb9,0xa3), b3(0xe3,0x83,0xbc)}, // replace('﹣', 'ー')
		{b3(0xef,0xbc,0x8d), b3(0xe3,0x83,0xbc)}, // replace('－', 'ー')
		{b3(0xe2,0x80,0x94), b3(0xe3,0x83,0xbc)}, // replace('—', 'ー')
		{b3(0xe2,0x80,0x95), b3(0xe3,0x83,0xbc)}, // replace('―', 'ー')
		{b3(0xe2,0x94,0x81), b3(0xe3,0x83,0xbc)}, // replace('━', 'ー')
		{b3(0xe2,0x94,0x80), b3(0xe3,0x83,0xbc)}, // replace('─', 'ー')
		{b1(0x2c), b3(0xe3,0x80,0x81)}, // replace(',', '、')
		{b1(0x2e), b3(0xe3,0x80,0x82)}, // replace('.', '。')
		{b3(0xef,0xbc,0x8c), b3(0xe3,0x80,0x81)}, // replace('，', '、')
		{b3(0xef,0xbc,0x8e), b3(0xe3,0x80,0x82)}, // replace('．', '。')
		{b1(0x21), b3(0xef,0xbc,0x81)}, // replace('!', '！')
		{b1(0x3f), b3(0xef,0xbc,0x9f)},	// replace('?', '？')
	}
	{
		std::string temp{ "\xEF\xBC\x9F" };
		// generate symbols (UTF32)

		//std::string temp = Convert(0xef,0xbc,0x81);
		//std::string str(arr);
		//auto temp = Convert({ 0xef,0xbc,0x81 });
		// pad 
		int32_t seq(1);
		for (size_t i = 0; i < punctuation_.size(); i++)
		{
			const utf8proc_uint8_t* pstring = reinterpret_cast<const utf8proc_uint8_t*>(&punctuation_[i].front());
			utf8proc_ssize_t size = punctuation_[i].size();
			utf8proc_int32_t cp = 0;
			for (utf8proc_ssize_t n = 0; (n = utf8proc_iterate(pstring, size, &cp)) > 0; pstring += n, size -= n)
			{
				assert(symbols_.find(cp) == symbols_.end());
				symbols_.emplace(std::make_pair(cp, seq++));		// 8
			}
		}

		// https://jrgraphix.net/r/Unicode/30A0-30FF
		// katakana ( U+30A0..U+30FF ), hiragana ( U+3040..U+309F )

		for (int32_t cp = 0x30A0; cp < 0x30FF; cp++)
		{
			assert(symbols_.find(cp) == symbols_.end());
			symbols_.emplace(std::make_pair(cp, seq++));		// 95
		}

		// alphabet
		for (int32_t cp = 0x0041; cp < 0x007b; cp++)
		{
			if (cp > 0x5a && cp < 0x61) continue;
			assert(symbols_.find(cp) == symbols_.end());
			symbols_.emplace(std::make_pair(cp, seq++));		// 52
		}

		// numbers
		for (int32_t cp = 0x30; cp < 0x3a; cp++)
		{
			assert(symbols_.find(cp) == symbols_.end());
			symbols_.emplace(std::make_pair(cp, seq++));		// 10
		}

		// eos
		eos_ = seq;
	}

	JSProcessor::~JSProcessor()
	{
		if (tagger_ != nullptr)
			MeCab::deleteTagger(tagger_);
	}

	void JSProcessor::ToSeq(const char* text, std::vector<int32_t>& seq, const char* enc)
	{
		std::string utf8;
		ToUTF8(utf8, text, enc);

		// cleaner
		for (auto& c : cleaner_)
			Replace(utf8, c, empty_);

		std::cout << utf8 << std::endl;

		// normalize
		for (auto& pair : normalize_)
			Replace(utf8, pair.first, pair.second);

		utf8proc_uint8_t* buffer = utf8proc_NFKC((const utf8proc_uint8_t*)utf8.c_str());
		if (buffer != nullptr)
		{
			utf8.assign((const char*)buffer);
			free(buffer);
		}

		// tokenizer
		std::vector<std::string> tokens;
		std::string token;
		for (auto& c : utf8)
		{
			bool isalpha = std::isalpha(c);
			bool isdigit = std::isdigit(c);
			bool ispunct = std::ispunct(c);
			char p = token.empty() ? 0 : token.back();
			if ((isalpha && !std::isalpha(p))
				|| (isdigit && !std::isdigit(p))
				|| (ispunct && !std::ispunct(p))) // continues
			{
				if (token.empty())
				{
					tokens.emplace_back(std::string{ c });
					continue;
				}
				else
				{
					tokens.emplace_back(token);
					token.clear();
				}
			}

			token.push_back(c);
		}
		tokens.emplace_back(token);

		utf8.clear();

		for (auto& token : tokens)
		{
			if (std::isalpha(token.front()))
			{
				for (auto& pair : e2k)
					Replace(token, pair.first, pair.second);
				utf8.append(token);
			}
			else
			{
				// pronunciation
				const char* result = tagger_->parse(token.c_str(), token.size());
				if (result)
				{
					std::istringstream input(result);
					std::string line;

					while (std::getline(input, line))
					{
						std::istringstream row(line);
						std::string column[2];

						size_t count;
						for (count = 0; count < 2 && std::getline(row, column[count], '\t'); ++count) {}
						//std::cout << line << std::endl;

						if (count == 2)
							utf8.append(column[1].empty() ? column[0] : column[1]);
					}
				}
				else
				{
					utf8.append(token);
				}
			}
		}

		// for test
		std::cout << utf8 << std::endl;

		seq.clear();

		const utf8proc_uint8_t* pstring = reinterpret_cast<const utf8proc_uint8_t*>(utf8.c_str());
		utf8proc_ssize_t size = utf8.size();
		utf8proc_int32_t cp = 0;
		for (utf8proc_ssize_t n = 0; (n = utf8proc_iterate(pstring, size, &cp)) > 0; pstring += n, size -= n)
		{
			auto it = symbols_.find(cp);
			if (it == symbols_.end())
			{
				std::cerr << "That code is not in the symbol => " << cp << std::endl;
				continue;
			}
			seq.emplace_back(it->second);
		}

		seq.emplace_back(eos_);
	}
}